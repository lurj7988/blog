import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c,b as n,d as a,f as s,e as t}from"./app-e0314230.js";const p="/blog/assets/architecture-d4fa7a3a.png",r="/blog/assets/channel-79fe68d3.png",d="/blog/assets/reactor-69379f5f.png",u={},h=t('<h2 id="netty概述" tabindex="-1"><a class="header-anchor" href="#netty概述" aria-hidden="true">#</a> Netty概述</h2><p><code>Netty</code>是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p><p><code>Netty</code>对<code>JDK</code>自带的NIO的API进行了良好的封装，解决了上述问题。且<code>Netty</code>拥有高性能、吞吐量更高，延迟更低，减少资源消耗，最小化不必要的内存复制等优点。</p><p><code>Netty</code>现在都在用的是4.x，5.x版本已经废弃，Netty4.x需要JDK 6以上版本支持。</p>',4),k={href:"https://github.com/netty/netty",target:"_blank",rel:"noopener noreferrer"},v=t('<h2 id="为什么使用netty" tabindex="-1"><a class="header-anchor" href="#为什么使用netty" aria-hidden="true">#</a> 为什么使用Netty</h2><h3 id="nio的缺点" tabindex="-1"><a class="header-anchor" href="#nio的缺点" aria-hidden="true">#</a> NIO的缺点</h3><p>NIO的主要问题是：</p><ul><li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>臭名昭著的 epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h3 id="netty的优点" tabindex="-1"><a class="header-anchor" href="#netty的优点" aria-hidden="true">#</a> Netty的优点</h3><ul><li>使用简单：封装了<code>NIO</code>的很多细节，使用更简单。</li><li>功能强大：预置了多种编解码功能，支持多种主流协议。</li><li>定制能力强：可以通过<code>ChannelHandler</code>对通信框架进行灵活地扩展。</li><li>性能高：通过与其他业界主流的<code>NIO</code>框架对比，<code>Netty</code>的综合性能最优。</li><li>稳定：<code>Netty</code>修复了已经发现的所有<code>NIO</code>的bug，让开发人员可以专注于业务本身。</li><li>社区活跃：<code>Netty</code>是活跃的开源项目，版本迭代周期短，bug修复速度快。</li></ul><h2 id="netty的使用场景" tabindex="-1"><a class="header-anchor" href="#netty的使用场景" aria-hidden="true">#</a> Netty的使用场景</h2><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的<code>RPC</code>框架必不可少，<code>Netty</code>作为异步高性能的通信框架，往往作为基础通信组件被这些<code>RPC</code>框架使用。典型的应用有：阿里分布式服务框架<code>Dubbo</code>的<code>RPC</code>框架使用<code>Dubbo</code>协议进行节点间通信，<code>Dubbo</code>协议默认使用<code>Netty</code>作为基础通信组件，用于实现。各进程节点之间的内部通信。<code>Rocketmq</code>底层也是用的<code>Netty</code>作为基础通信组件。</p><p>游戏行业：无论是手游服务端还是大型的网络游戏，<code>Java</code>语言得到了越来越广泛的应用。<code>Netty</code>作为高性能的基础通信组件，它本身提供了<code>TCP/UDP</code>和<code>HTTP</code>协议栈。</p><p>大数据领域：经典的 Hadoop 的高性能通信和序列化组件<code>Avro</code>的<code>RPC</code>框架，默认采用<code>Netty</code>进行跨界点通信，它的<code>Netty Service</code>基于<code>Netty</code>框架二次封装实现。</p><h2 id="netty的特点" tabindex="-1"><a class="header-anchor" href="#netty的特点" aria-hidden="true">#</a> Netty的特点</h2><p><code>Netty</code>的对<code>JDK</code>自带的NIO的API进行封装，解决上述问题，主要特点有：</p><ul><li>设计优雅 适用于各种传输类型的统一API - 阻塞和非阻塞Socket基于灵活且可扩展的事件模型，可以清晰地分离关注点高度可定制的线程模型-单线程，一个或多个线程池真正的无连接数据报套接字支持（自3.1起）</li><li>高性能 、高吞吐、低延迟、低消耗</li><li>最小化不必要的内存复制</li><li>安全完整的<code>SSL/TLS</code>和StartTLS支持</li><li>高并发：<code>Netty</code>是一款基于NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。</li><li>传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li><li>封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。</li><li>社区活跃，不断更新 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入</li><li>使用方便详细记录的Javadoc，用户指南和示例没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了</li></ul><h2 id="netty的架构" tabindex="-1"><a class="header-anchor" href="#netty的架构" aria-hidden="true">#</a> Netty的架构</h2><h3 id="功能特性" tabindex="-1"><a class="header-anchor" href="#功能特性" aria-hidden="true">#</a> 功能特性</h3><figure><img src="'+p+`" alt="Netty的架构" tabindex="0" loading="lazy"><figcaption>Netty的架构</figcaption></figure><ul><li>传输服务支持BIO和NIO</li><li>容器集成支持OSGI、JBossMC、Spring、Guice容器</li><li>协议支持HTTP、Protobuf、二进制、文本、WebSocket等一系列常见协议都支持。 还支持通过实行编码解码逻辑来实现自定义协议</li><li>Core核心可扩展事件模型、通用通信API、支持零拷贝的ByteBuf缓冲对象</li></ul><h3 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件" aria-hidden="true">#</a> 核心组件</h3><h4 id="bootstrap、serverbootstrap" tabindex="-1"><a class="header-anchor" href="#bootstrap、serverbootstrap" aria-hidden="true">#</a> Bootstrap、ServerBootstrap</h4><p>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p><h4 id="future、channelfuture" tabindex="-1"><a class="header-anchor" href="#future、channelfuture" aria-hidden="true">#</a> Future、ChannelFuture</h4><p>正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p><h4 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> Channel</h4><p>Netty网络通信的组件，能够用于执行网络I/O操作。Channel为用户提供：</p><ul><li>当前网络连接的通道的状态（例如是否打开？是否已连接？）</li><li>网络连接的配置参数（例如接收缓冲区大小）</li><li>提供异步的网络<code>I/O</code>操作(如建立连接，读写，绑定端口)，异步调用意味着任何<code>I/O</code>调用都将立即返回，并且不保证在调用结束时所请求的<code>I/O</code>操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以<code>I/O</code>操作成功、失败或取消时回调通知调用方。</li><li>支持关联<code>I/O</code>操作与对应的处理程序</li></ul><p>不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，下面是一些常用的Channel类型</p><ul><li>NioSocketChannel，异步的客户端TCP Socket连接</li><li>NioServerSocketChannel，异步的服务器端TCP Socket 连接</li><li>NioDatagramChannel，异步的UDP连接</li><li>NioSctpChannel，异步的客户端Sctp连接</li><li>NioSctpServerChannel，异步的Sctp服务器端连接 这些通道涵盖了UDP和TCP网络IO以及文件IO.</li></ul><h4 id="selector" tabindex="-1"><a class="header-anchor" href="#selector" aria-hidden="true">#</a> Selector</h4><p>Netty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个Channel。</p><h4 id="nioeventloop" tabindex="-1"><a class="header-anchor" href="#nioeventloop" aria-hidden="true">#</a> NioEventLoop</h4><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：</p><ul><li>I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。</li><li>非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。</li></ul><p>两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。</p><h4 id="nioeventloopgroup" tabindex="-1"><a class="header-anchor" href="#nioeventloopgroup" aria-hidden="true">#</a> NioEventLoopGroup</h4><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。</p><h4 id="channelhandler" tabindex="-1"><a class="header-anchor" href="#channelhandler" aria-hidden="true">#</a> ChannelHandler</h4><p>ChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。</p><p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p><ul><li>ChannelInboundHandler用于处理入站I/O事件</li><li>ChannelOutboundHandler用于处理出站I/O操作</li></ul><p>或者使用以下适配器类：</p><ul><li>ChannelInboundHandlerAdapter用于处理入站I/O事件</li><li>ChannelOutboundHandlerAdapter用于处理出站I/O操作</li><li>ChannelDuplexHandler用于处理入站和出站事件</li></ul><h4 id="channelhandlercontext" tabindex="-1"><a class="header-anchor" href="#channelhandlercontext" aria-hidden="true">#</a> ChannelHandlerContext</h4><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</p><h4 id="channelpipeline" tabindex="-1"><a class="header-anchor" href="#channelpipeline" aria-hidden="true">#</a> ChannelPipeline</h4><p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。</p><p>下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。 I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>                                                 I/O Request
                                            via Channel or
                                        ChannelHandlerContext
                                                      |
  +---------------------------------------------------+---------------+
  |                           ChannelPipeline         |               |
  |                                                  \\|/              |
  |    +---------------------+            +-----------+----------+    |
  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |
  |    +----------+----------+            +-----------+----------+    |
  |              /|\\                                  |               |
  |               |                                  \\|/              |
  |    +----------+----------+            +-----------+----------+    |
  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
  |    +----------+----------+            +-----------+----------+    |
  |              /|\\                                  .               |
  |               .                                   .               |
  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
  |        [ method call]                       [method call]         |
  |               .                                   .               |
  |               .                                  \\|/              |
  |    +----------+----------+            +-----------+----------+    |
  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
  |    +----------+----------+            +-----------+----------+    |
  |              /|\\                                  |               |
  |               |                                  \\|/              |
  |    +----------+----------+            +-----------+----------+    |
  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |
  |    +----------+----------+            +-----------+----------+    |
  |              /|\\                                  |               |
  +---------------+-----------------------------------+---------------+
                  |                                  \\|/
  +---------------+-----------------------------------+---------------+
  |               |                                   |               |
  |       [ Socket.read() ]                    [ Socket.write() ]     |
  |                                                                   |
  |  Netty Internal I/O Threads (Transport Implementation)            |
  +-------------------------------------------------------------------+

123456789101112131415161718192021222324252627282930313233343536373839
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。入站Handler处理程序通常处理由图底部的I/O线程生成的入站数据。通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。</p><p>出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p><p>在<code>Netty</code>中每个<code>Channel</code>都有且仅有一个<code>ChannelPipeline</code>与之对应, 它们的组成关系如下:</p><figure><img src="`+r+`" alt="channel" tabindex="0" loading="lazy"><figcaption>channel</figcaption></figure><p>一个<code>Channel</code>包含了一个<code>ChannelPipeline</code>, 而<code>ChannelPipeline</code>中又维护了一个由<code>ChannelHandlerContext</code>组成的双向链表, 并且每个<code>ChannelHandlerContext</code>中又关联着一个<code>ChannelHandler</code>。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。</p><h2 id="netty服务端过程初始化并启动过程" tabindex="-1"><a class="header-anchor" href="#netty服务端过程初始化并启动过程" aria-hidden="true">#</a> Netty服务端过程初始化并启动过程</h2><p>初始化并启动Netty服务端过程如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建mainReactor</span>
    <span class="token class-name">NioEventLoopGroup</span> boosGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建工作线程组</span>
    <span class="token class-name">NioEventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token class-name">ServerBootstrap</span> serverBootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serverBootstrap 
                <span class="token comment">// 组装NioEventLoopGroup </span>
            <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boosGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>
                <span class="token comment">// 设置channel类型为NIO类型</span>
            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            <span class="token comment">// 设置连接配置参数</span>
            <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span><span class="token constant">SO_BACKLOG</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span><span class="token constant">SO_KEEPALIVE</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span><span class="token constant">TCP_NODELAY</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
            <span class="token comment">// 配置入站、出站事件handler</span>
            <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 配置入站、出站事件channel</span>
                    ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 绑定端口</span>
    <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span>
    serverBootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>future <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: 端口[&quot;</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">&quot;]绑定成功!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;端口[&quot;</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">&quot;]绑定失败!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本过程如下：</p><ol><li>初始化创建2个NioEventLoopGroup，其中boosGroup用于Accetpt连接建立事件并分发请求， workerGroup用于处理I/O读写事件和业务逻辑</li><li>基于ServerBootstrap(服务端启动引导类)，配置EventLoopGroup、Channel类型，连接参数、配置入站、出站事件handler</li><li>绑定端口，开始工作</li></ol><h2 id="服务端netty的工作架构图" tabindex="-1"><a class="header-anchor" href="#服务端netty的工作架构图" aria-hidden="true">#</a> 服务端Netty的工作架构图</h2><p>结合上面的介绍的Netty Reactor模型，介绍服务端Netty的工作架构图：</p><figure><img src="`+d+'" alt="reactor" tabindex="0" loading="lazy"><figcaption>reactor</figcaption></figure><p>server端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。</p><p>每个Boss NioEventLoop循环执行的任务包含3步：</p><ol><li>轮询accept事件</li><li>处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上</li><li>处理任务队列中的任务，runAllTasks。</li></ol><p>任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。</p><p>每个Worker NioEventLoop循环执行的任务包含3步：</p><ol><li>轮询read、write事件；</li><li>处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理</li><li>处理任务队列中的任务，runAllTasks。</li></ol><h2 id="示例项目" tabindex="-1"><a class="header-anchor" href="#示例项目" aria-hidden="true">#</a> 示例项目</h2>',67),b={href:"https://github.com/waylau/netty-4-user-guide",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/waylau/netty-4-user-guide-demos",target:"_blank",rel:"noopener noreferrer"},y={href:"https://github.com/fuzhengwei/itstack-demo-netty",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/fuzhengwei/itstack-demo-rpc",target:"_blank",rel:"noopener noreferrer"},C=n("h2",{id:"参考文献",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考文献","aria-hidden":"true"},"#"),a(" 参考文献")],-1),N={href:"https://blog.csdn.net/crazymakercircle/article/details/124588880",target:"_blank",rel:"noopener noreferrer"},g={href:"https://zhuanlan.zhihu.com/p/474844021",target:"_blank",rel:"noopener noreferrer"};function O(I,S){const e=l("ExternalLinkIcon");return i(),c("div",null,[h,n("p",null,[a("开源地址："),n("a",k,[a("https://github.com/netty/netty"),s(e)])]),v,n("ul",null,[n("li",null,[n("a",b,[a("https://github.com/waylau/netty-4-user-guide"),s(e)])]),n("li",null,[n("a",m,[a("https://github.com/waylau/netty-4-user-guide-demos"),s(e)])]),n("li",null,[n("a",y,[a("https://github.com/fuzhengwei/itstack-demo-netty"),s(e)])]),n("li",null,[n("a",f,[a("https://github.com/fuzhengwei/itstack-demo-rpc"),s(e)])])]),C,n("ul",null,[n("li",null,[n("a",N,[a("https://blog.csdn.net/crazymakercircle/article/details/124588880"),s(e)])]),n("li",null,[n("a",g,[a("https://zhuanlan.zhihu.com/p/474844021"),s(e)])])])])}const w=o(u,[["render",O],["__file","intro.html.vue"]]);export{w as default};
